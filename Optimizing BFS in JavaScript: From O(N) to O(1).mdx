# Optimizing BFS in JavaScript: From O(N) to O(1) Queue Operations

When implementing BFS or Level Order Traversals in JavaScript, you might unknowingly be using O(N) operations. This guide shows you how to optimize them to O(1) per operation.

## The Problem: Array.shift() is O(N)

The `Array.shift()` method removes the first element from an array, which requires shifting all remaining elements one position to the left. This makes it an O(N) operation.

## Solution: Use a Head Pointer

Instead of removing elements, we can use a **head pointer** to track our position in the queue. This makes dequeue operations O(1).

---

## Basic BFS Traversal

### Before: O(N) per dequeue
```javascript
const bfs = (root) => {
  if (!root) return;
  const queue = [root];
  const result = [];

  while (queue.length) {
    const current = queue.shift();  // âš ï¸ O(N) operation
    result.push(current.value);

    for (const child of current.children) {
      queue.push(child);
    }
  }

  return result;
};
```

### After: O(1) per dequeue
```javascript
const bfs = (root) => {
  if (!root) return;
  const queue = [root];
  const result = [];
  let head = 0;  // ðŸ‘ˆ Head pointer

  while (head < queue.length) {  // ðŸ‘ˆ Check head instead of queue.length
    const current = queue[head++];  // ðŸ‘ˆ O(1) dequeue
    result.push(current.value);

    for (const child of current.children) {
      queue.push(child);
    }
  }

  return result;
};
```

**Key changes:**
- Added `head` pointer starting at 0
- Changed loop condition to `head < queue.length`
- Use `queue[head++]` instead of `queue.shift()`

---

## Level Order Traversal

For level-by-level traversal, we need to track how many nodes are in the current level.

```javascript
const levelOrder = (root) => {
  if (!root) return [];

  const queue = [root];
  let head = 0;
  const result = [];

  while (head < queue.length) {
    const levelSize = queue.length - head;  // ðŸ‘ˆ Nodes in current level
    const level = [];

    for (let i = 0; i < levelSize; i++) {
      const current = queue[head++];
      level.push(current.value);

      for (const child of current.children) {
        queue.push(child);
      }
    }

    result.push(level);
  }

  return result;
};
```

**How it works:**
1. `levelSize = queue.length - head` gives the exact number of nodes at the current level
2. Process exactly `levelSize` nodes before moving to the next level
3. New children are added to the end of the queue (next level)

---

## Zigzag Level Order Traversal

Zigzag traversal alternates direction between levels. The naive approach uses `unshift()`, which is also O(N).

### Before: Using unshift() - O(N)
```javascript
const zigzagLevelOrder = (root) => {
  if (!root) return [];

  const queue = [root];
  let head = 0;
  const result = [];
  let leftToRight = true;

  while (head < queue.length) {
    const levelSize = queue.length - head;
    const level = [];

    for (let i = 0; i < levelSize; i++) {
      const current = queue[head++];

      if (leftToRight) {
        level.push(current.value);
      } else {
        level.unshift(current.value);  // âš ï¸ O(N) operation
      }

      for (const child of current.children) {
        queue.push(child);
      }
    }

    result.push(level);
    leftToRight = !leftToRight;
  }

  return result;
};
```

### After: Using index calculation - O(1)
```javascript
const zigzagLevelOrder = (root) => {
  if (!root) return [];

  const queue = [root];
  let head = 0;
  const result = [];
  let leftToRight = true;

  while (head < queue.length) {
    const levelSize = queue.length - head;
    const level = new Array(levelSize);  // ðŸ‘ˆ Pre-allocate array

    for (let i = 0; i < levelSize; i++) {
      const current = queue[head++];

      // ðŸ‘‡ Calculate index based on direction
      const index = leftToRight ? i : levelSize - 1 - i;
      level[index] = current.value;  // ðŸ‘ˆ O(1) direct assignment

      for (const child of current.children) {
        queue.push(child);
      }
    }

    result.push(level);
    leftToRight = !leftToRight;
  }

  return result;
};
```

**The trick:**
- Pre-allocate the level array with exact size
- Calculate the correct index based on direction
- Use direct assignment `level[index] = value` instead of `unshift()`

When going **left-to-right**: `index = i` (0, 1, 2, ...)
When going **right-to-left**: `index = levelSize - 1 - i` (2, 1, 0, ...)

---

## Performance Comparison

| Operation | Time Complexity |
|-----------|----------------|
| `array.shift()` | O(N) |
| `array.unshift()` | O(N) |
| `array[head++]` | O(1) |
| `array[index] = value` | O(1) |

**Overall impact:**
- **Before**: O(NÂ²) for BFS with N nodes
- **After**: O(N) for BFS with N nodes

---

## Memory Considerations

The head pointer approach leaves processed elements in the array. For very large traversals, you might want to periodically clean up:

```javascript
// Optional: Clean up processed elements periodically
if (head > 1000) {
  queue.splice(0, head);
  head = 0;
}
```

However, for typical DSA problems, this cleanup is usually unnecessary.

---

## Summary

1. **Use `head` pointer instead of `shift()` for O(1) dequeue**
2. **Use index calculation instead of `unshift()` for O(1) insertion**
3. **Pre-allocate arrays when you know the size**
4. **Remember: `queue.length - head` gives current level size**

These optimizations can significantly improve your BFS and tree traversal performance in JavaScript
