# DOM Manipulation with TypeScript

A comprehensive guide to working with the Document Object Model (DOM) using TypeScript, covering type safety, best practices, and common patterns.

## Getting Started

TypeScript provides built-in type definitions for DOM APIs through the `lib.dom.d.ts` file, which is included by default in most TypeScript configurations.

### Basic Setup

```typescript
// tsconfig.json
{
  "compilerOptions": {
    "target": "ES6",
    "lib": ["ES6", "DOM"],
    "strict": true
  }
}
```

## Selecting Elements

TypeScript provides specific types for different element selections, helping catch errors at compile time.

### querySelector and querySelectorAll

```typescript
// Type assertion for specific element types
const button = document.querySelector('button') as HTMLButtonElement;
const input = document.querySelector('#email') as HTMLInputElement;

// More type-safe approach with null checking
const form = document.querySelector<HTMLFormElement>('#myForm');
if (form) {
  form.addEventListener('submit', handleSubmit);
}

// Working with NodeList
const paragraphs = document.querySelectorAll<HTMLParagraphElement>('p');
paragraphs.forEach(p => {
  p.style.color = 'blue';
});
```

### getElementById and other selectors

```typescript
// getElementById returns HTMLElement | null
const header = document.getElementById('header');

// Type narrowing with type guards
if (header instanceof HTMLHeadingElement) {
  header.textContent = 'New Heading';
}

// getElementsByClassName returns HTMLCollection
const items = document.getElementsByClassName('item');
Array.from(items).forEach((item) => {
  item.classList.add('active');
});
```

## Creating and Modifying Elements

TypeScript ensures you're using the correct properties and methods for each element type.

### Creating Elements

```typescript
// Create elements with proper typing
const div = document.createElement('div');
div.className = 'container';
div.id = 'main-container';

const img = document.createElement('img');
img.src = 'image.jpg';
img.alt = 'Description';

const link = document.createElement('a');
link.href = 'https://example.com';
link.textContent = 'Visit Site';
link.target = '_blank';

// Append to DOM
document.body.appendChild(div);
```

### Modifying Element Properties

```typescript
interface Task {
  id: number;
  title: string;
  completed: boolean;
}

function createTaskElement(task: Task): HTMLDivElement {
  const taskEl = document.createElement('div');
  taskEl.className = 'task';
  taskEl.dataset.id = task.id.toString();

  const checkbox = document.createElement('input');
  checkbox.type = 'checkbox';
  checkbox.checked = task.completed;

  const label = document.createElement('label');
  label.textContent = task.title;

  taskEl.appendChild(checkbox);
  taskEl.appendChild(label);

  return taskEl;
}
```

## Event Handling

TypeScript provides strong typing for event objects, making event handling safer.

### Basic Event Listeners

```typescript
const button = document.querySelector<HTMLButtonElement>('#submitBtn');

button?.addEventListener('click', (event: MouseEvent) => {
  event.preventDefault();
  console.log('Button clicked at:', event.clientX, event.clientY);
});

// Input events with proper typing
const searchInput = document.querySelector<HTMLInputElement>('#search');

searchInput?.addEventListener('input', (event: Event) => {
  const target = event.target as HTMLInputElement;
  console.log('Search query:', target.value);
});
```

### Form Handling

```typescript
interface FormData {
  username: string;
  email: string;
  age: number;
}

const form = document.querySelector<HTMLFormElement>('#userForm');

form?.addEventListener('submit', (event: SubmitEvent) => {
  event.preventDefault();

  const formData = new FormData(event.currentTarget as HTMLFormElement);

  const data: FormData = {
    username: formData.get('username') as string,
    email: formData.get('email') as string,
    age: Number(formData.get('age'))
  };

  console.log('Form data:', data);
});
```

### Event Delegation

```typescript
const taskList = document.querySelector<HTMLUListElement>('#taskList');

taskList?.addEventListener('click', (event: MouseEvent) => {
  const target = event.target as HTMLElement;

  if (target.matches('.delete-btn')) {
    const taskItem = target.closest('li');
    taskItem?.remove();
  }

  if (target.matches('.edit-btn')) {
    const taskItem = target.closest('li');
    if (taskItem) {
      editTask(taskItem);
    }
  }
});

function editTask(taskItem: HTMLLIElement): void {
  // Edit logic here
}
```

## Working with Attributes and Classes

```typescript
const element = document.querySelector<HTMLDivElement>('.box');

if (element) {
  // Class manipulation
  element.classList.add('active', 'highlighted');
  element.classList.remove('hidden');
  element.classList.toggle('expanded');

  const hasActive = element.classList.contains('active');

  // Attribute manipulation
  element.setAttribute('data-status', 'complete');
  const status = element.getAttribute('data-status');
  element.removeAttribute('data-temp');

  // Dataset API (camelCase conversion)
  element.dataset.userId = '123';
  element.dataset.userName = 'John';

  console.log(element.dataset.userId); // "123"
}
```

## Type Guards and Null Safety

TypeScript's strict null checks help prevent runtime errors.

```typescript
// Type guard function
function isHTMLElement(element: Element | null): element is HTMLElement {
  return element !== null && element instanceof HTMLElement;
}

// Safe element access
function updateElement(selector: string, text: string): void {
  const element = document.querySelector(selector);

  if (isHTMLElement(element)) {
    element.textContent = text;
  } else {
    console.warn(`Element not found: ${selector}`);
  }
}

// Handling specific element types
function getInputValue(id: string): string | null {
  const input = document.getElementById(id);

  if (input instanceof HTMLInputElement) {
    return input.value;
  }

  return null;
}
```

## Advanced Patterns

### Custom Element Wrapper Class

```typescript
class DOMElement<T extends HTMLElement> {
  constructor(private element: T) {}

  addClass(...classes: string[]): this {
    this.element.classList.add(...classes);
    return this;
  }

  removeClass(...classes: string[]): this {
    this.element.classList.remove(...classes);
    return this;
  }

  on<K extends keyof HTMLElementEventMap>(
    event: K,
    handler: (event: HTMLElementEventMap[K]) => void
  ): this {
    this.element.addEventListener(event, handler);
    return this;
  }

  setText(text: string): this {
    this.element.textContent = text;
    return this;
  }

  append(child: HTMLElement): this {
    this.element.appendChild(child);
    return this;
  }

  getElement(): T {
    return this.element;
  }
}

// Usage
const button = new DOMElement(document.createElement('button'))
  .addClass('btn', 'btn-primary')
  .setText('Click Me')
  .on('click', () => console.log('Clicked!'));

document.body.appendChild(button.getElement());
```

### Template Builder

```typescript
class ElementBuilder<T extends keyof HTMLElementTagNameMap> {
  private element: HTMLElementTagNameMap[T];

  constructor(tagName: T) {
    this.element = document.createElement(tagName);
  }

  setId(id: string): this {
    this.element.id = id;
    return this;
  }

  addClasses(...classes: string[]): this {
    this.element.classList.add(...classes);
    return this;
  }

  setAttributes(attrs: Record<string, string>): this {
    Object.entries(attrs).forEach(([key, value]) => {
      this.element.setAttribute(key, value);
    });
    return this;
  }

  setContent(content: string): this {
    this.element.textContent = content;
    return this;
  }

  appendChild(child: HTMLElement): this {
    this.element.appendChild(child);
    return this;
  }

  build(): HTMLElementTagNameMap[T] {
    return this.element;
  }
}

// Usage
const card = new ElementBuilder('div')
  .setId('user-card')
  .addClasses('card', 'shadow')
  .setAttributes({ 'data-user-id': '42' })
  .build();
```

## Best Practices

### 1. Always Handle Null Cases

```typescript
// Bad
const button = document.querySelector('button');
button.addEventListener('click', handler); // Potential error!

// Good
const button = document.querySelector('button');
button?.addEventListener('click', handler);

// Better
const button = document.querySelector<HTMLButtonElement>('#myButton');
if (button) {
  button.addEventListener('click', handler);
} else {
  console.error('Button not found');
}
```

### 2. Use Type Assertions Carefully

```typescript
// Avoid
const input = document.querySelector('#email') as HTMLInputElement;
input.value = 'test'; // Will throw if element doesn't exist

// Prefer
const input = document.querySelector<HTMLInputElement>('#email');
if (input) {
  input.value = 'test';
}
```

### 3. Create Reusable Utility Functions

```typescript
function createElement<K extends keyof HTMLElementTagNameMap>(
  tag: K,
  options?: {
    classes?: string[];
    id?: string;
    attributes?: Record<string, string>;
    textContent?: string;
  }
): HTMLElementTagNameMap[K] {
  const element = document.createElement(tag);

  if (options?.classes) {
    element.classList.add(...options.classes);
  }

  if (options?.id) {
    element.id = options.id;
  }

  if (options?.attributes) {
    Object.entries(options.attributes).forEach(([key, value]) => {
      element.setAttribute(key, value);
    });
  }

  if (options?.textContent) {
    element.textContent = options.textContent;
  }

  return element;
}

// Usage
const button = createElement('button', {
  classes: ['btn', 'btn-primary'],
  id: 'submit-btn',
  textContent: 'Submit',
  attributes: { type: 'submit' }
});
```

### 4. Use Generic Types for Flexibility

```typescript
function querySelector<T extends Element>(
  selector: string,
  parent: Document | Element = document
): T | null {
  return parent.querySelector<T>(selector);
}

function querySelectorAll<T extends Element>(
  selector: string,
  parent: Document | Element = document
): T[] {
  return Array.from(parent.querySelectorAll<T>(selector));
}

// Usage with proper typing
const button = querySelector<HTMLButtonElement>('#myBtn');
const inputs = querySelectorAll<HTMLInputElement>('input[type="text"]');
```

## Common Pitfalls to Avoid

1. **Forgetting null checks** - Always account for elements that might not exist
2. **Incorrect type assertions** - Use type guards instead of assumptions
3. **Not leveraging TypeScript's event types** - Use proper event types for better autocomplete
4. **Mutating DOM in loops** - Consider using DocumentFragment for batch operations
5. **Ignoring TypeScript errors** - Don't use `any` or `@ts-ignore` to bypass type safety

## Conclusion

TypeScript brings significant benefits to DOM manipulation through type safety, better tooling, and early error detection. By following these patterns and best practices, you can write more robust and maintainable client-side code.
